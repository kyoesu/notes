# LINQ запросы в C#. Таблицы DataGridView.
      
LINQ (Language-Integrated Query) представляет простой и удобный язык запросов к источнику данных. В качестве источника данных может выступать объект, реализующий интерфейс IEnumerable (например, стандартные коллекции, массивы), набор данных DataSet, документ XML. Но вне зависимости от типа источника LINQ позволяет применить ко всем один и тот же подход для выборки данных.

Существует несколько разновидностей LINQ:
* LINQ to Objects: применяется для работы с массивами и коллекциями
* LINQ to Entities: используется при обращении к базам данных через технологию Entity Framework
* LINQ to Sql: технология доступа к данным в MS SQL Server
* LINQ to XML: применяется при работе с файлами XML
* LINQ to DataSet: применяется при работе с объектом DataSet
* Parallel LINQ (PLINQ): используется для выполнения параллельной запросов

В этой главе речь пойдет прежде всего о LINQ to Objects, но в последующих материалах также будут затронуты и другие разновидности LINQ.

![img](pic/doc1.png)

В чем же удобство LINQ? Посмотрим на простейшем примере. Выберем из массива строки, начинающиеся на определенную букву и отсортируем полученный список:

    string[] teams = {"Бавария", "Боруссия", "Реал Мадрид", "Манчестер Сити", "ПСЖ", "Барселона"};
    
    var selectedTeams = new List<string>();
    foreach(string s in teams)
    {
        if (s.ToUpper().StartsWith("Б"))
            selectedTeams.Add(s);
    }
    selectedTeams.Sort();
    
    foreach (string s in selectedTeams)
        Console.WriteLine(s);

Теперь проведем те же действия с помощью LINQ:

    string[] teams = {"Бавария", "Боруссия", "Реал Мадрид", "Манчестер Сити", "ПСЖ", "Барселона"};
    
    var selectedTeams = from t in teams // определяем каждый объект из teams как t
                        where t.ToUpper().StartsWith("Б") //фильтрация по критерию
                        orderby t  // упорядочиваем по возрастанию
                        select t; // выбираем объект
    
    foreach (string s in selectedTeams)
                Console.WriteLine(s);
        Console.WriteLine(s);

    string[] teams = {"Бавария", "Боруссия", "Реал Мадрид", "Манчестер Сити", "ПСЖ", "Барселона"};
    
    var selectedTeams = from t in teams // определяем каждый объект из teams как t
                        where t.ToUpper().StartsWith("Б") //фильтрация по критерию
                        orderby t  // упорядочиваем по возрастанию
                        select t; // выбираем объект
    
    foreach (string s in selectedTeams)
    Console.WriteLine(s);
Чтобы использовать функциональность LINQ, убедимся, что в файле подключено пространство имен System.LINQ.

Итак, код стал меньше и проще. В принципе все выражение можно было бы записать в одну строку: 

    var selectedTeams = from t in teams where t.ToUpper().StartsWith("Б") orderby t select t. 

Но для более понятной логической разбивки я поместил каждое отдельное подвыражение на отдельной строке.

Простейшее определение запроса LINQ выглядит следующим образом:

    from переменная in набор_объектов
    select переменная;

Итак, что делает этот запрос LINQ? Выражение *from t in teams* проходит по всем элементам массива *teams* и определяет каждый элемент как *t*. Используя переменную *t* мы можем проводить над ней разные операции.

Несмотря на то, что мы не указываем тип переменной *t*, выражения LINQ являются строго типизированными. То есть среда автоматически распознает, что набор teams состоит из объектов *string*, поэтому переменная *t* будет рассматриваться в качестве строки.

Далее с помощью оператора *where* проводится фильтрация объектов, и если объект соответствует критерию (в данном случае начальная буква должна быть "*Б*"), то этот объект передается дальше.

Оператор *orderby* упорядочивает по возрастанию, то есть сортирует выбранные объекты.

Оператор *select* передает выбранные значения в результирующую выборку, которая возвращается LINQ-выражением.

В данном случае результатом выражения LINQ является объект *IEnumerable<T>*. Нередко результирующая выборка определяется с помощью ключевого слова *var*, тогда компилятор на этапе компиляции сам выводит тип.

Преимуществом подобных запросов также является и то, что они интуитивно похожи на запросы языка SQL, хотя и имеют некоторые отличия.

